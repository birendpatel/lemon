#! /usr/bin/env python3

# Copyright (C) 2021 Biren Patel. GNU General Public License v3.0.
#
# This script builds the C Lemon compiler in either installation, release, or
# debug mode via GNU make and GCC. Invoke the script with one of the following
# arguments. If no arugments are passed, the build will default to 'debug'.
#
# (0) debug     : Build with assertions, debug info, and no optimisations
# (1) release   : Builds with optimisations; no trace, no debug, no assertions
# (2) install   : Build in release mode and installs Lemon at /usr/local/bin
# (3) uninstall : Uninstall Lemon from /usr/local/bin
# (3) clean     : Remove files created by debug and release; does not uninstall

from subprocess import run 
from sys import argv
from os import system, remove

#-------------------------------------------------------------------------------
# configurable makefile parameters

compiler = "gcc"
executable_name = "lemon"
debug = "debug"
release = "release"
install_path = "/usr/local/bin"

files = [
    "./src/main.c",
    "./src/xerror.c",
    "./src/options.c",
    "./src/file.c",
    "./src/jobs.c",
    "./src/scanner.c",
    "./src/parser.c",
    "./src/symtab.c",
    "./src/assets/kmap.c",
    "./extern/cexception/CException.c"
]

library_flags = [
    "-lpthread"
]

common_flags = [
    "-std=gnu17",
    "-Wall",
    "-Wextra",
    "-Wpedantic",
    "-Wconversion",
    "-Wcast-qual",
    "-Wnull-dereference",
    "-Wdouble-promotion",
    "-DCOLOURS",
    "-Wno-unused-function" 
]

debug_flags = [
    "-ggdb",
    "-O0",
    "-DDEBUG"
]

release_flags = [
    "-O3",
    "-march=native"
]

#-------------------------------------------------------------------------------
# makefile templates

preamble = """\
CC = {}
CFLAGS = {}
"""

mode = """\
.PHONY: {0} {0}_deps

{0}: CFLAGS += {1}
{0}: {0}_deps ./{0}/lemon
\t@echo "\\nbuild finished successfully."
\t@echo "Lemon was compiled in {0} mode."
"""

clean = """\
.PHONY: clean

clean:
\t@rm -rf ./{} ./{}
\t@echo "directories cleaned"
"""

install = """\
.PHONY: install uninstall

install: {0}
\tcp ./{0}/{1} {2}
\t@echo "\\nLemon installed successfully."

uninstall:
\trm -f {2}/{1}
\t@echo "\\nLemon uninstalled successfully."
"""

#-------------------------------------------------------------------------------
# create build rules for each mode; essentially the makefile tools and functions
# like vpath, addprefix, etc are replaced by brute force python.

def build(target: str) -> str:
    if target == debug:
        script = mode.format(debug, ' '.join(debug_flags))
    elif target == release:
        script = mode.format(release, ' '.join(release_flags))
    else:
        ValueError("invalid target: {}".format(target))

    for file in files:
        script += create_object_rule(target, file)

    script += create_exe_rule(target, script)

    return script

#create a makefile rule for the input C source file; the target will be placed
#in the input directory.
def create_object_rule(target: str, file: str) -> str:
    command = "gcc -MM {}".format(file)

    result = run(command, check=True, shell=True, capture_output=True)

    directory = "./{}/".format(target)
    prerequisites = insert_source(result.stdout.decode(), file)
    recipe = "\n\t$(CC) $(CFLAGS) -c -o $@ $<\n\n"

    return directory + prerequisites + recipe

#take a gcc -MM generated rule as input and inject the input file as the
#the first prerequisite
def insert_source(rule: str, file: str) -> str:
    colon = rule.find(':') + 1
    assert(colon != 0)

    return rule[:colon] + " " + file + " " + rule[colon:]

#create a makefile rule for the GNU linker; the input script must contain
#all the object file rules necessary for all the object files that must be
#passed to the linker
def create_exe_rule(target: str, script: str) -> str:
    directory = "./{}/{}:".format(target, executable_name)
    prerequisites = get_linker_prerequisites(script)
    recipe = "\n\t$(CC) -o $@ $^ {}\n\n".format(' '.join(library_flags))

    return directory + prerequisites + recipe

#finds all object-file paths within the input string and returns them with
#whitespace separation
def get_linker_prerequisites(script: str) -> str:
    objects = []
    pattern = ".o:"
    tokens = script.split()

    for word in tokens:
        tail = word[-3:]

        if tail == pattern:
            word_no_colon = word[:-1]

            objects.append(word_no_colon)

    return ' '.join(objects)

#-------------------------------------------------------------------------------
# temporarily create a makefile on disk, invoke it with a rule, and then delete
# it. This guarantees that file dependencies are always up to date and prevents
# end users from accidentally using a stale build configuration.
#
# system() is used because generates real-time build messages from the makefile
# and preserves the colour output from gcc. This is harder to accomplish via
# the subprocess and pty modules.

def get_rule() -> str:
    argc = len(argv)
    err = None

    if argc == 1:
        return "debug"
    elif argc == 2:
        return argv[1]
    else:
        raise ValueError("more than one rule provided")


def create_script() -> str:
    makefile = ""

    makefile += preamble.format(compiler, ' '.join(common_flags))
    makefile += build(debug)
    makefile += build(release)
    makefile += install.format(release, executable_name, install_path)
    makefile += clean.format(debug, release)

    return makefile

if __name__ == "__main__":
    command = "make {}".format(get_rule())
    script = create_script()

    with open("makefile", mode='w') as file:
        file.write(script)

    print(command)
    print(script)
    system(command)
    remove("makefile")
