#! /usr/bin/env python3

# Copyright (C) 2021 Biren Patel. GNU General Public License v3.0.
#
# This script generates a makefile which separates installation, release, and
# debug builds into separate folders. The GNU C compiler is required in order to
# resolve file dependencies.
#
# Invoke this script from the terminal without arguments to build the C Lemon
# compiler in debug mode. Optionally, pass one of the following arguments:
#
# (1) release   : Builds Lemon in optimised mode
# (2) install   : Installs Lemon at /usr/local/bin (may require sudo)
# (3) uninstall : Uninstall Lemon at /usr/local/bin (may require sudo)
# (3) clean     : Remove all files generated by the debug and release builds

from subprocess import run 
from sys import argv
from os import system, remove


#-------------------------------------------------------------------------------

executable_name = "lemon"
debug_dir = "./debug/"
release_dir = "./release/"

#any time a new C source file is created for the compiler, its path from the
#root project directory must be added to this list
files = [
    "./src/main.c",
    "./src/xerror.c",
    "./src/options.c",
    "./src/file.c",
    "./src/jobs.c",
    "./src/scanner.c",
    "./src/parser.c",
    "./src/symtab.c",
    "./src/assets/kmap.c",
    "./extern/cexception/CException.c"
]

#system static and dynamic libraries must be added to this list. Just add the
#name; the script will resolve the path
libraries = [
    "pthread"
]

#-------------------------------------------------------------------------------
#The start of any good makefile; the common compiler flags used by all builds
#can be added here.
#
#Do not change the compiler! Both the Lemon source code and the build system
#absolutely depend on GCC.

preamble = """\
CC = gcc

CFLAGS = -std=gnu17 -Wall -Wextra -Werror -Wpedantic
CFLAGS += -Wconversion -Wcast-qual -Wnull-dereference
CFLAGS += -Wdouble-promotion

# enable coloured error output from ./src/xerror.c
CFLAGS += -DCOLOURS

#allows for templated data structures in ./src/lib
CFLAGS += -Wno-unused-function

.PHONY: all\n
"""

#-------------------------------------------------------------------------------
#Separate build requirements are accomplished by GNU Make's target specific
#variable values. See the GNU Make manual chapter 6 section 11. Add build
#specific compiler flags and user instructions/notifications here.

debug_build = """\
.PHONY: debug debug_deps

debug: CFLAGS += -ggdb -O0 -DDEBUG
debug: debug_deps {0}lemon
\t@echo "\\nBuild finished successfully."
\t@echo "Lemon was compiled in debug mode."

debug_deps:
\t@mkdir -p {0}\n
""".format(debug_dir)

release_build = """\
.PHONY: release release_deps

release: CFLAGS += -O3 -march=native
release: release_deps {0}lemon
\t@echo "\\nBuild finished successfully."
\t@echo "Lemon was compiled in release mode."

release_deps:
\t@mkdir -p {0}\n
""".format(release_dir)

#-------------------------------------------------------------------------------
#cleanup

clean = """\
.PHONY: clean

clean:
\t@rm -rf {} {}
\t@echo "directories cleaned"
""".format(debug_dir, release_dir)

#-------------------------------------------------------------------------------
#installation

install = """\
.PHONY: install uninstall

INSTALL_PATH = /usr/local/bin

install: release
\tcp ./release/{0} $(INSTALL_PATH)
\t@echo "\\nLemon installed successfully."

uninstall:
\trm -f $(INSTALL_PATH){0}
\t@echo "\\nLemon uninstalled successfully."
""".format(executable_name)

#-------------------------------------------------------------------------------
#Reserved makefile rules carried over from the previous build system. Not in
#use.

memcheck = """\
.PHONY: memcheck

memcheck: debug
\t valgrind --leak-check=yes ./debug/lemon ...\n
"""

tests = """\
.PHONY: test test_scanner

TESTNAMES = test_scanner

test: $(TESTNAMES)

unity.o: unity.c unity.h unity_internals.h
\t$(CC) -c $< -o $@

test_scanner: debug
\tcd ./test; python3 ./test_scanner.py
"""

#-------------------------------------------------------------------------------
#This collection of functions creates all of the build rules. Essentially, the
#makefile functions and concepts like vpath, addprefix, etc are all replaced by
#by brute force python.

def build(directory: str) -> str:
    global files
    script = ""

    if directory == debug_dir:
        script += debug_build
    elif directory == release_dir:
        script += release_build
    else:
        ValueError("invalid target directory: {}".format(directory))

    for file in files:
        script += create_object_rule(directory, file)

    script += create_exe_rule(directory, script)

    return script

#create a makefile rule for the input C source file; the target will be placed
#in the input directory.
def create_object_rule(directory: str, file: str) -> str:
    command = "gcc -MM {}".format(file)

    result = run(command, check=True, shell=True, capture_output=True)

    target = directory
    prerequisites = insert_source(result.stdout.decode(), file)
    recipe = "\n\t$(CC) $(CFLAGS) -c -o $@ $<\n\n"

    return target + prerequisites + recipe

#take a gcc -MM generated rule as input and inject the input file as the
#the first prerequisite
def insert_source(rule: str, file: str) -> str:
    colon = rule.find(':') + 1
    assert(colon != 0)

    return rule[:colon] + " " + file + " " + rule[colon:]

#create a makefile rule for the GNU linker; the input script must contain
#all the object file rules necessary for all the object files that must be
#passed to the linker
def create_exe_rule(directory: str, script: str) -> str:
    global executable_name

    target = directory + executable_name + ": "
    prerequisites = get_linker_prerequisites(script)
    recipe = "\n\t$(CC) -o $@ $^ {}\n\n".format(get_libraries())

    return target + prerequisites + recipe

#finds all object-file paths within the input string and returns them with
#whitespace separation
def get_linker_prerequisites(script: str) -> str:
    objects = []
    pattern = ".o:"
    tokens = script.split()

    for word in tokens:
        tail = word[-3:]

        if tail == pattern:
            word_no_colon = word[:-1]

            objects.append(word_no_colon)

    return ' '.join(objects)

#transform library names in the global library list into valid GCC inputs
def get_libraries() -> str:
    global libraries

    flags = []

    for lib in libraries:
        flags.append('-l' + lib)

    return ' '.join(flags)

#-------------------------------------------------------------------------------

#return the empty string or argv[1] if it exists; throw ValueError if more than
#one rule found
def get_rule() -> str:
    argc = len(argv)
    err = None

    if argc == 1:
        return ""
    elif argc == 2:
        return argv[1]
    else:
        raise ValueError()

def create_makefile_script() -> str:
    makefile = preamble
    makefile += build(debug_dir)
    makefile += build(release_dir)
    makefile += install
    makefile += clean

    return makefile

def script_to_disk(script: str, filename: str) -> None:
    with open(filename, mode='w') as file:
        file.write(script)

#-------------------------------------------------------------------------------
# temporarily create a makefile on disk, invoke it with a rule, and then delete
# it. This guarantees that file dependencies are always up to date and prevents
# end users from accidentally using a stale build configuration.
#
# system() is used because generates real-time build messages from the makefile
# and preserves the colour output from gcc. This is harder to accomplish via
# the subprocess and pty modules.

if __name__ == "__main__":
    script_name = "makefile"

    try:
        script = create_makefile_script()
        command = "make {}".format(get_rule())
        script_to_disk(script, script_name)
        system(command)
        remove(script_name)
    except ValueError:
        print("build failed; more than one rule provided")
