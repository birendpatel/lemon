# Language Specification for the Lemon programming Language
# Copyright (C) 2021 Biren Patel
# GNU General Public License v3.0

#-------------------------------------------------------------------------------
# Notation
#-------------------------------------------------------------------------------

The metasyntax for the Lemon grammar is specified via extended Backus-Naur form.
Some standard EBNF notation has been replaced with regex-like equivalents for
readability, familiarity, and simplicity.

nonterminal		<foo>
terminal		"foo"
lexical element		FOO
rule termination	\n\n
definition		::=
empty string		Îµ

Metasyntax operators in order of decreasing precedence:

repeat zero or more	*
repeat one or more	+
optional		?
grouping		()
alternation		|

#-------------------------------------------------------------------------------
# Lemon operator precedence
#-------------------------------------------------------------------------------

Priority	Operators	Grouping	Comment
--------	---------	--------	-------
1		()		LR		Function call, grouping
-		[]		LR		Composite types indexing/decls
-		.		LR		Method and attribute access
2		!		RL		Logical NOT
-		'		RL		Bitwise NOT
-		+		RL		Unary positive
-		-		RL		Unary minus
-		*		RL		Indirection
-		&		RL		Address of
-		(foo)		RL		Type casting
3		*		LR		Multiplication
-		/		LR		Division
-		%		LR		Mod
4		+		LR		Binary addition
-		-		LR		Binary subtraction
5		>>		LR		Right shift
-		<<		LR		Left Shift
6		>		LR		Greater than
-		<		LR		Less than
-		>=		LR		Greater than or equal to
-		<=		LR		Less than or equal to
7		==		LR		Logical equals
-		!=		LR		Logical not equals
8		&		LR		Bitwise AND
9		^		LR		Bitwise XOR
10		|		LR		Bitwise OR
11		&&		LR		Logical AND
12		||		LR		Logical OR
13		=		RL		Assignment

#-------------------------------------------------------------------------------
# Lexical Grammar
#-------------------------------------------------------------------------------

IDENTIFIER ::= [a-zA-Z_][a-zA-Z_0-9]*

LITERAL ::= INT_LITERAL
	  | FLOAT_LITERAL
	  | STRING_LITERAL
	  | BOOL_LITERAL
	  | RVAR_LITERAL
	  | ARRAY_LITERAL

#-------------------------------------------------------------------------------
# Syntactical Grammar
#-------------------------------------------------------------------------------

<file> ::= <declaration>* "EOF" ;

#-------------------------------------------------------------------------------
# Lemon does not require a main() function as its entry point. Therefore,
# statements may exist at the top level alongside declarations.
#-------------------------------------------------------------------------------

<declaration> ::= <type declaration>
		| <function declaration>
		| <variable declaration>
		| <statement>

#TODO
<type declaration> ::= "struct" IDENTIFIER "{" "}" ";"

#TODO
<function declaration> ::= "func" IDENTIFIER

#-------------------------------------------------------------------------------
# variable declarations default to the zero-value of the type if no explicit
# initializer is given. The optional mut terminal allows the variable to
# be modified after its declaration. Variables in Lemon are default immutable
# to take advantage of optimisations.
#
# Lemon does not allow multiple declarations such as "let x, y: int = 0, 1;".
#-------------------------------------------------------------------------------

<variable declaration> ::= "let" "mut"? IDENTIFIER ":" IDENTIFIER 
			   ("=" LITERAL)? ";"

#TODO
<statement> ::= <expression statement>
	      | <block statement>

<block statement> ::= "{" <declaration>* "}"

<expression statement> ::= <expression> ";"

#-------------------------------------------------------------------------------
# The expression grammar is stratified according to the operator precedence
# rules.
#-------------------------------------------------------------------------------

<expression> ::= <assignment>

<assignment> ::= IDENTIFIER "=" <assignment> | <logical or>

<logical or> ::= <logical and> ("||" <logical and>)*

<logical and> ::= <bitwise or> ("&&" <bitwise or>)*

<bitwise or> ::= <bitwise xor> ("|" <bitwise xor>)*

<bitwise xor> ::= <bitwise and> ("^" <bitwise and>)*

<bitwise and> ::= <equality> ("&" <equality)*

<equality> ::= <comparison> (("==" | "!=") <comparison)*

<comparison> ::= <left shift> ((">" | "<" | ">=" | "<=") <left shift>)*

<left shift> ::= <right shift> ("<<" <right shift>)*

<right shift> ::= <term> (">>" <term>)*

<term> ::= <factor> (("+" | "-") <factor>)*

<factor> ::= <unary> (("*" | "/" | "%") <unary>)*

<unary> ::= ("-" | "+" | "'" | "!" | "*" | "&" | <type cast>) <unary> | <access>

<type cast> ::= "(" IDENTIFIER ")"

<access> ::= <atom> (<call> | <attribute> | <index>)*

<call> ::= "(" <arguments> ")"

<arguments> ::= <expression> ("," <expression) *

<attribute> ::= "." IDENTIFIER

<index> ::= "[" <expression> "]"

<atom> ::= IDENTIFIER | LITERAL | "(" <expression> ")"
