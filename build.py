#! /usr/bin/env python3

# Copyright (C) 2021 Biren Patel. GNU General Public License v3.0.

from re import findall
from subprocess import run

files = [
    "./src/main.c",
    "./src/xerror.c",
    "./src/options.c",
    "./src/file.c",
    "./src/jobs.c",
    "./src/scanner.c",
    "./src/parser.c",
    "./src/symtab.c",
    "./src/assets/kmap.c",
    "./extern/cexception/CException.c"
]

#-------------------------------------------------------------------------------

preamble = """\
# -*- MakeFile -*-
# Copyright (C) 2021 Biren Patel. GNU General Public License v3.0.
# This makefile is auto-generated by build.py

CC = gcc

CFLAGS = -std=gnu17 -Wall -Wextra -Werror -Wpedantic
CFLAGS += -Wconversion -Wcast-qual -Wnull-dereference
CFLAGS += -Wdouble-promotion
CFLAGS += -DCOLOURS

#macros such as make_vector defined in the templated data structures
#located at ./src/lib create unused functions for the sake of end-user
#convenience. Compilation will fail without disabling the flag.
CFLAGS += -Wno-unused-function

vpath %.h ./src
vpath %.h ./src/lib
vpath %.h ./src/assets
vpath %.h ./extern/unity
vpath %.h ./extern/cexception

vpath %.c ./src
vpath %.c ./src/lib
vpath %.c ./src/assets
vpath %.c ./extern/unity
vpath %.c ./extern/cexception

.PHONY: all\n
"""

#-------------------------------------------------------------------------------

debug_dir = "./debug/"

debug_build = """\
.PHONY: debug debug_deps

debug: CFLAGS += -ggdb -O0 -DDEBUG
debug: debug_deps {0}lemon
\t@echo "\\nBuild finished successfully."
\t@echo "Lemon was compiled in debug mode."
\t@echo "Issue 'make release' to turn on optimisations."

debug_deps:
\t@mkdir -p {0}\n
""".format(debug_dir)

#-------------------------------------------------------------------------------

release_dir = "./release/"

release_build = """\
.PHONY: release release_deps

release: CFLAGS += -O3 -march=native
release: release_deps {0}lemon
\t@echo "\\nBuild finished successfully."
\t@echo "Lemon was compiled in release mode."

release_deps:
\t@mkdir -p {0}\n
""".format(release_dir)

#-------------------------------------------------------------------------------

def build(files: list, directory: str) -> str:
    script = ""

    if directory == debug_dir:
        script += debug_build
    elif directory == release_dir:
        script += release-build
    else:
        ValueError("invalid target directory: {}".format(directory))

    for file in files:
        script += add_path(directory, create_recipe(file))

    return script

#return the implicit object file rule to allow make to auto-deduce the recipe
def create_recipe(file: str) -> str:
    assert(file[-2:] == ".c")

    command = "gcc -MM {}".format(file)

    result = run(command, check=True, shell=True, capture_output=True)

    recipe = result.stdout.decode() + "\n"

    return recipe

#prefixes the recipe with a dir path so that the debug and release target files
#do not intermix in the root directory and cause a build corruption
def add_path(directory: str, recipe: str) -> str:
    return directory + recipe

#-------------------------------------------------------------------------------

if __name__ == "__main__":
    files = [
        "./src/main.c",
        "./src/xerror.c",
        "./src/options.c",
        "./src/file.c",
        "./src/jobs.c",
        "./src/scanner.c",
        "./src/parser.c",
        "./src/symtab.c",
        "./src/assets/kmap.c",
        "./extern/cexception/CException.c"
    ]

    makefile = preamble

    makefile += build(files, debug_dir)
