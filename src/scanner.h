// Copyright (C) 2021 Biren Patel. GNU General Public License v3.0.

#pragma once

#include <stdint.h>

#include "options.h"
#include "xerror.h"

typedef enum token_type {
	//markers
	_INVALID = 0,
	_EOF,
	_IDENTIFIER,

	//atomic literals
	_LITERALINT,
	_LITERALFLOAT,
	_LITERALSTR,

	//punctuation
	_SEMICOLON,	// ;
	_LEFTBRACKET,	// [
	_RIGHTBRACKET,	// ]
	_LEFTPAREN,	// (
	_RIGHTPAREN,	// )
	_LEFTBRACE,	// {
	_RIGHTBRACE,	// }
	_DOT,		// .
	_TILDE,		// ~
	_COMMA,		// ,
	_COLON,		// :

	//operators
	_EQUAL,		// =
	_EQUALEQUAL,	// ==
	_NOTEQUAL,	// !=
	_NOT,		// !
	_AND,		// &&
	_OR,		// ||
	_BITNOT,	// '
	_AMPERSAND,	// &
	_BITOR,		// |
	_BITXOR,	// ^
	_LSHIFT,	// <<
	_RSHIFT,	// >>
	_GREATER,	// >
	_GEQ,		// >=
	_LESS,		// <
	_LEQ,		// <=
	_ADD,		// +
	_MINUS,		// -
	_STAR,		// *
	_DIV,		// /
	_MOD,		// %

	//keywords, control flow
	_FOR,
	_WHILE,
	_BREAK,
	_CONTINUE,
	_IF,
	_ELSE,
	_SWITCH,
	_CASE,
	_DEFAULT,
	_FALLTHROUGH,
	_GOTO,
	_LABEL,

	//keywords, assignment
	_LET,
	_MUT,
	_NULL,
	_TRUE,
	_FALSE,

	//keywords, composition
	_STRUCT,
	_IMPORT,

	//keywords, procedures
	_FUNC,
	_PRIV,
	_PUB,
	_RETURN,
	_SELF,
	_VOID,

	//total
	_TOKEN_TYPE_COUNT,
} token_type;

//tokens are words generated by the scanner during its lexical analysis.
//
//token.lexeme is a string view of length token.len into the input source code.
//token.type is the enum token_type but it uses uint32_t to guarantee the
//struct packing behavior.
typedef struct token {
	char *lexeme;
	uint32_t type;
	uint32_t line;
	uint32_t len;
	uint32_t flags;
} token;

//token.flags
#define TOKEN_OKAY	0
#define TOKEN_BAD_NUM	1 << 0 // ill-formed number literal
#define TOKEN_BAD_STR	1 << 1 // ill-formed string literal

//stderr
void token_print(token tok);

typedef struct scanner scanner;

//initialized in a new detached thread
xerror scanner_init(scanner **self, char *src, options *opt);

//fetch a token, if any, from the front of the scanner's communication channel.
//
//if no token is available and channel is in a valid open state, then the caller
//thread will suspend and wait without timeout.
//
//If the caller receives a token of type _EOF, the scanner will not send any
//additional tokens and can be safely shutdown with scanner_free().
xerror scanner_recv(scanner *self, token *tok);

//fails if the communication channel is busy
xerror scanner_free(scanner *self);
