/**
 * @file nodes.h
 * @author Copyright (C) 2021 Biren Patel. GNU General Public License v3.0.
 * @brief Abstract syntax tree nodes and their heap init-free functions.
 */

#pragma once

#include <stdbool.h>
#include <stdint.h> //uint64_t

#include "xerror.h"
#include "lib/vector.h"

//node typedefs need to be specified up front due to the large amount of
//circular references. exprs can contain stmts, stmts can contain exprs, etc..
typedef struct file file;
typedef struct action action;
typedef struct decl decl;
typedef struct stmt stmt;
typedef struct expr expr;

//char names need to be extracted for later symbol tables. wrap them in a string
//to help keep track of which len variables match to which char pointers.
//note that this sacrificies 4 bytes of padding.
typedef struct string {
	char *ptr;
	uint32_t len;
} string;

//method member for function declarations
typedef struct receiver {
	string name;
	bool is_pointer;
} receiver;

//parameter object for each struct member or for each function parameter
typedef struct param {
	string name;
	string type;
	bool private; //for structs
} param;

//vectors contained in various nodes. Since nodes are simple bags of data, the
//user (aka the parser) must implement the actual vector operations.
alias_vector(action)
declare_vector(action, action)

alias_vector(param)
declare_vector(param, param)

/*******************************************************************************
 * @struct decl
 * @brief Tagged union of declaration nodes.
 * @remark The Lemon grammar expands declarations to include statements. But,
 * statement nodes are handled in a separate struct due to their complexity.
 ******************************************************************************/
struct decl {
	enum {
		TYP,
		FUNC,
		VAR,
	} type;
	union {
		struct {
			string name;
			param_vector params;
		} typ;
		struct {
			string name;
			param_vector params;
			string rettype;
			receiver recv;
			stmt *block;
			bool private;
		} func;
		struct {
			string name;
			string datatype;
			expr *value;
			bool mutable;
		} var;
	};
};

/*******************************************************************************
 * @struct stmt
 * @brief Tagged union of statement nodes
 ******************************************************************************/
struct stmt {
	enum {
		GENERIC,
	} type;
	union {
		struct {
			expr *expression;
		} generic;
	};
};

/*******************************************************************************
 * @struct action
 * @brief Thin wrapper over decls and stmts to allow polymorphism in the
 * vector elements for file nodes.
 ******************************************************************************/
struct action {
	enum {
		DECL,
		STMT,
	} type;
	union {
		decl declaration;
		stmt statement;
	};
};

/*******************************************************************************
 * @struct file
 * @brief The root node of every AST generated by the parser is a file node
 * whose children are declaration nodes. The id is simply a unique randomly
 * generated number for differentiating the ASTs of each input file.
 * @details <file> ::= <declaration>* "EOF"
 ******************************************************************************/
struct file {
	uint64_t id;
	action_vector actions;
};
